# Simulación Laboral Septiembre 2025 - No Country

## Información
**Programa:** Simulación Laboral No Country  
**Período:** 29 septiembre - 3 noviembre 2025  
**Rol:** Ethical Hacker  
**Estado:** Participante activo  

## Programa
Simulación laboral intensiva de 5 semanas diseñada para replicar entornos de trabajo reales en equipos multidisciplinarios. El programa abarca múltiples especialidades tecnológicas incluyendo desarrollo web, mobile, ciberseguridad, AI, UX/UI design, data science y marketing digital.

## Metodología
- **Metodología:** Framework Agile/Scrum con sprints semanales
- **Formato:** Trabajo colaborativo en equipos balanceados
- **Modalidad:** 100% remoto con reuniones obligatorias
- **Duración:** 5 semanas (Semana 0 + 4 semanas de desarrollo)

## Cronograma de Actividades

### Semana 0 - Planificación
- Formación de equipos mediante análisis de perfiles y matching por roles
- Sprint Planning obligatorio
- Presentación de integrantes y definición de roles
- Sprint Demo y feedback inicial

### Semanas 1-3 - Ejecución
- Sprint Planning semanal (reuniones obligatorias)
- Daily meetings para coordinación de actividades
- Desarrollo incremental del proyecto
- Sprint Demos semanales
- Gestión de recursos y entregables

### Semana 4 - Presentación
- Finalización de desarrollos
- Preparación de entregables finales
- Creación de video demo del proyecto
- Demo Day comunitario
- Evaluación y feedback entre compañeros

## Competencias
- **Trabajo en equipo multidisciplinario:** Colaboración efectiva con profesionales de diferentes especialidades
- **Metodologías ágiles:** Implementación práctica de Scrum en proyectos reales
- **Gestión de proyectos:** Planificación, ejecución y seguimiento de sprints
- **Comunicación técnica:** Presentaciones de avances y demos técnicas
- **Ciberseguridad aplicada:** Desarrollo de soluciones desde perspectiva de ethical hacking

## Herramientas
- Plataforma No Country para gestión de proyectos
- Discord para comunicación y coordinación de equipo
- ChatGPT para asistencia en desarrollo
- Herramientas de desarrollo específicas según proyecto asignado

## Objetivos
- Experiencia práctica en entornos de trabajo remoto
- Desarrollo de habilidades de colaboración interprofesional
- Implementación de buenas prácticas en ciberseguridad
- Creación de portfolio con proyecto real
- Networking con profesionales de la industria tech

## Resultados
- Proyecto completamente funcional desarrollado en equipo
- Video demostración técnica del producto
- Certificación de participación en simulación laboral
- Feedback profesional de pares y mentores
- Ampliación de red de contactos profesionales

---


# Proyecto No Country Septiembre 2025: Kit de Seguridad para Super App Financiera


## Descripción
Kit de Seguridad para Super App Financiera
Vertical: Cybersecurity

Sector de Negocio: Fintech

Necesidad del cliente
Las super apps manejan grandes volúmenes de datos sensibles y deben asegurar la confidencialidad e integridad de la información.

Sin embargo, muchas startups carecen de guías y herramientas para implementar buenas prácticas de seguridad desde el inicio.

Validación de mercado
La transformación digital ha convertido las fintech en un objetivo atractivo para los atacantes:

Amenazas como *phishing*, *ransomware* y brechas de datos pueden costar millones y dañar la confianza de los usuarios.
- Debido a la interconectividad de APIs y servicios, la seguridad se convierte en un factor crítico para la supervivencia del negocio.

Expectativa
Diseñar un kit de seguridad integral para super apps financieras que incluya:

Plantillas de políticas.
Lista de chequeo de configuración segura.
Guías de buenas prácticas.
El kit debe permitir que equipos sin infraestructura de seguridad compleja:

Implementen controles básicos.
Realicen autoevaluaciones.
Entregables deseados
Manual de mejores prácticas (cifrado, autenticación, control de acceso).
Checklist de configuración segura para infraestructura y APIs.
Scripts de pruebas básicas de vulnerabilidades (OWASP ZAP, SAST).
Guía de concientización para el equipo (phishing, ingeniería social).
Funcionalidades
Must-have
Guía paso a paso para configurar autenticación multifactor y cifrado de datos.
Plantillas de políticas de contraseñas y gestión de credenciales.
Herramientas de escaneo automático de vulnerabilidades de bajo costo.
Nice-to-have
Ejemplos de flujos de remediación de incidentes menores.
Integración con pipelines de CI/CD para análisis de seguridad.
Glosario de términos de cumplimiento (GDPR, PCI DSS).

## Resumen

Problema: Las super apps manejan datos financieros sensibles, pero muchas startups carecen de guías y herramientas para aplicar seguridad desde el inicio.

**Contexto**

- Las fintech son un blanco prioritario de ataques (phishing, ransomware, fugas de datos).
- La interconexión de APIs aumenta la superficie de ataque.
- La seguridad es crítica para la confianza y la supervivencia del negocio.

**Objetivo: Diseñar un kit**

- Implementar controles básicos.
- Hacer autoevaluaciones de seguridad.
- Entregables
- Manual de mejores prácticas (cifrado, autenticación, control de acceso).
- Checklist de configuración segura (infraestructura, APIs).
- Scripts para pruebas de vulnerabilidades (OWASP ZAP, SAST).
- Guía de concientización (phishing, ingeniería social).

****Funcionalidades:**

- Must-have: MFA, cifrado, plantillas de contraseñas y credenciales, escaneo automático económico.
- Nice-to-have: ejemplos de respuesta a incidentes menores, integración con CI/CD, glosario de cumplimiento (GDPR, PCI DSS).

  ## Plan

1. Resumen

Proveer un kit reproducible (políticas, checklists, scripts y guías) que permita a una super app fintech implementar controles básicos de seguridad, realizar autoevaluaciones y escanear vulnerabilidades con coste bajo.

2. Alcance y supuestos

- Aplicable a una super app (web + API + mobile backend).
- Prioridad en confidencialidad e integridad de datos financieros. No cubre infra on-premises industriales complejas.
- Stack típico: contenedores (Docker), repos GitHub/GitLab, CI (GitHub Actions/GitLab CI/Jenkins).

3. Entregables finales (lo que te pedirán entregar)
- Manual de mejores prácticas (cifrado, autenticación, control de acceso).
- Checklist de configuración segura (infra y APIs) en formato checklist.md / Excel.
- Scripts de pruebas automáticas: ZAP (baseline), Trivy (containers/IaC), Semgrep (SAST), y ejemplos SCA/SAST simples.
- Plantillas de políticas (contraseñas, gestión de credenciales, acceso remoto, manejo de incidentes).
- Guía de concienciación para equipo (phishing + checklist de simulación).
- Reporte ejecutivo y ficha con hallazgos y remediaciones (priorizadas).

4. Cronograma (sprint por sprint)
- (Kickoff & Discovery): inventario activos, flujo de datos, mapa de dependencias. Entrega: Diagrama de flujo + inventario. (1 semana)
- (Políticas & Gobierno): plantillas y clasificación de datos. Entrega: paquete políticas.
- (Hardening Infra): aplicar CIS / baselines mínimos en infra de staging. Entrega: checklist aplicado + evidencia.
- (Auth & Data Protection): MFA, cifrado en tránsito y reposo, KMS. Entrega: configuración y pruebas básicas.
- (SDLC: SAST/SCA/CI): integrar Semgrep + SCA + secret scanning en PRs. Entrega: pipelines con scans.
- (DAST & Infra scanning): ZAP scans automatizados + Trivy para imágenes + IaC scanning. Entrega: scripts y reportes.
- (Detección & IR): logging, alerting, playbook de IR y simulacro. Entrega: playbook y simulacro ejecutado.
- (Delivery & Handover): empaquetar kit, documentación, formación y checklist final.

5. Fases y pasos detallados (Pauta paso a paso)

**Fase 0 — Kickoff**
Objetivo: conocer la app, sus datos críticos, y su superficie de ataque.

Tareas:
- Reunir stakeholders (PO, dev lead, infra, legal/compliance si existe).
- Inventario mínimo: endpoints públicos, APIs internas, flujos de pago, 3rd-party providers (pagos, KYC), repositorios, buckets/DBs que contienen PII o datos de pago.
- Clasificación rápida de datos: PII, financieros, sensibles, públicos.
- Diagrama de arquitectura (simple): frontend, backend, DB, colas, 3rd parties.
- Threat model rápido (STRIDE-lite): priorizar 5 ataques más probables.
- Output: inventario_activos.md, diagrama_architectura.png, threat_model.md.

**Fase 1 — Políticas & Gobierno**
Objetivo: dejar por escrito normas operativas básicas.

Tareas:
- Plantilla: Política de contraseñas y gestión de credenciales.
- Plantilla: Política de control de acceso (principio de menor privilegio).
- Política: Gestión de secrets (uso de vault / KMS; prohibir secrets en repos).
- Data retention y responsabilidades frente a GDPR/PCI.
- Salida mínima: politicas/ con archivos markdown listos para adaptar.
- Plantilla rápida — Política de contraseña (extracto):
- Longitud mínima: 12 caracteres recomendados (usar passphrases). No obligar símbolos complejos. Evitar rotaciones obligatorias sin motivo.
- Rechazar contraseñas comprometidas (check con listas públicas).
- MFA obligatorio para cuentas de administración y acceso a prod.

**Fase 2 — Hardening de Infra y Baselines**
Objetivo: aplicar configuraciones seguras reproducibles.

Tareas:
- Aplicar CIS Benchmarks relevantes (Linux, Docker, Kubernetes si aplica). Usa checklists automatizables.
- Configurar reglas de firewall, segmentación de red entre servicios y base de datos.
- Reducir exposición: eliminar puertos innecesarios, healthy checks restringidos.
- Habilitar rotación de claves y KMS para cifrado de datos en reposo.
- Herramientas & comandos:
- Usa herramientas de auditoría (CIS-CAT o scanners open-source) para evidencias.

**Fase 3 — Autenticación y Autorización (MFA y NIST)**
Objetivo: garantizar identidades robustas.

Tareas:
- Implementar MFA para accesos de usuarios administrativos y empleados críticos.
- Revisar sesiones, tiempos de expiración y re-autenticación (seguir NIST SP 800-63 recomendaciones para AAL levels).
- Revisar y aplicar OAuth2 / OIDC scopes correctamente.

Checklist:
- MFA en consola cloud, paneles, dashboards, herramientas de administración.
- Tokens cortos y refresh tokens con revocación.
- Registro y monitorización de intentos de login.

**Fase 4 — Protección de Datos (en tránsito y en reposo)**
Objetivo: cifrar datos sensibles y proteger claves.

Tareas:
- TLS obligatorio en todas las conexiones (HSTS, certificados válidos).
- Cifrado en reposo: base de datos y buckets con KMS.
- Minimizar datos almacenados: tokenizar/mascarar datos de pago cuando sea posible.

**Fase 5 — SDLC Seguro: SAST, SCA, Secret Scanning
**Objetivo: detectar vulnerabilidades en código y dependencias antes del deploy.

Tareas:
Integrar Semgrep (SAST leve) en PRs.
Ejecutar SCA (dependency scanning) en cada build: npm audit / pip-audit / trivy repo scan.
Habilitar secret scanning (GitHub secret scanning o trufflehog) en repos.

Ejemplos rápidos (comandos):

Bandit (Python):
pip install bandit
bandit -r src/ -f json -o bandit-report.json

Semgrep en local:
pip install semgrep
semgrep --config=auto

**Fase 6 — DAST & Scanning Automático (ZAP, Trivy)**

Objetivo: automatizar pruebas dinámicas y scans de imágenes/IaC.

Tareas:
- Instalar y automatizar OWASP ZAP para env. staging. Ejecutar escaneo baseline en cada release.
- Integrar Trivy para escaneo de imágenes y repos (IaC misconfigurations).
- Comando ZAP (ejemplo con Docker):

# escaneo baseline simple
docker run --rm -v $(pwd):/zap/wrk/:rw owasp/zap2docker-stable zap-baseline.py -t https://staging.example.com -r zap-report.html

Comando Trivy (imagen):

trivy image --format json -o trivy-report.json myorg/myapp:latest

**Fase 7 — Integración en CI/CD (pruebas en PRs y gates)**

Objetivo: automatizar gates que bloqueen PRs peligrosos.

Pautas:
- Pipelines mínimos: lint -> tests -> SAST/SCA -> DAST (opcional en PRs) -> deploy.
- Fallo en SAST/SCA debe bloquear merge automático hasta revisión.
- Snippets (GitHub Actions): Semgrep + Trivy

name: Security checks
on: [pull_request]
jobs:
  semgrep:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run Semgrep
        uses: returntocorp/semgrep-action@v1
  trivy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run Trivy
        uses: aquasecurity/trivy-action@v0.2.0
        with:
          image-ref: ${{ env.IMAGE_REF }}

**Fase 8 — Detección, Logging y Monitorización**
Objetivo: saber cuándo algo va mal.

Tareas:
Centralizar logs (ELK/EFK or a managed SIEM). Guardar logs de autenticación y transacciones críticas.
Definir alertas: múltiples fallos de login, picos en errores 5xx, aumento de latencia inusual.
Retención de logs acorde a cumplimiento (GDPR mínimo, y requisitos regulatorios si aplica).

**Fase 9 — Plan de Respuesta a Incidentes (IR) y Simulacros**
Objetivo: preparar playbooks y practicar.

Playbook mínimo (incidente de fuga de datos):
- Detección: activar canal IR (Slack/esc.alarm).
- Contención: bloquear accesos, tomar snapshots, aislar servicios comprometidos.
- Preservación: preservar evidencias (logs, memory dumps) en almacenamiento forense.
- Erradicación: parche, rotación de claves, remover backdoors.
- Recuperación: restaurar servicios controlados.
- Post-mortem: informe y lecciones aprendidas.

**Fase 10 — Formación y Concienciación**
Objetivo: reducir riesgo humano (phishing, ingeniería social).

Acciones:
- Simulacro de phishing trimestral mínimo.
- Checklist de seguridad para empleados (no compartir contraseñas, reportar emails sospechosos).

**6. Checklists rápidos (extractos)**
Checklist mínimo de despliegue seguro (pre-prod -> prod)

**7. Scripts y plantillas (entregable técnico)**
Incluye: zap-run.sh, trivy-scan.sh, semgrep-workflow.yml, password-policy.md, ir-playbook.md.

Ejemplo simple: zap-run.sh

#!/usr/bin/env bash
TARGET=$1
docker run --rm -v $(pwd):/zap/wrk/:rw owasp/zap2docker-stable zap-baseline.py -t "$TARGET" -r zap-report.html

**8. Formato de entrega y presentación final**

Carpeta deliverable/ con:

docs/ (manuales y políticas)

scripts/ (scanners y pipelines)

checklists/ (xlsx / md)

reports/ (ejemplos de reportes con vulnerabilidades priorizadas)

Presentación ejecutiva (1 slide) + ficha operativa (1 página) con prioridades y los 3 riesgos críticos.

**9. Priorización de remediación (Matriz sencilla)**

Alta (P0): vulnerabilidades RCE / exposición de datos de pago / credenciales públicas.

Media (P1): XSS, CSRF no explotadas en prod, dependencias con CVE moderadas.

Baja (P2): issues de configuración no expuestos.

---

# Manual de Cifrado

Cifrar infraestructura cloud, bases de datos, endpoints y móviles (cumplir GDPR y PCI DSS).

## Cifrado en tránsito TLS (linux)
- /etc/nginx: 
- /etc/letsencrypt/live

### Certbot 
Open-source que automatiza la obtención y renovación de certificados TLS de Let’s Encrypt,
Let’s Encrypt es la Autoridad de Certificación gratuita que emite los certificados que dicen que el dominio es tu propiedad.
Otra alternativa podría ser acme.sh

**Instalación**
Actualizamos los repos (IMPORTANTE)
**sudo apt update**

Instalamos el servicio que permite instalar paquetes snap que utiliza Certbot
**sudo apt install -y snapd**

Creamos el enlace para que certbot sea accesible como cualquier otro binario y pueda ejecutarse en /usr/bin
sudo ln -s /snap/bin/certbot /usr/bin/certbot

#### Obtener el certificado
--nginx le dice a Certbot que use el plugin nginx, hará la validación (HTTP-01), obtendrá el certificado y modificará tu bloque de servidor para añadir ssl_certificate/ssl_certificate_key y redirección a HTTPS si aceptas.
**sudo certbot --nginx -d example.com -d <URL>**
Otra alternativa es hacerlo no interactivo.

**Ficheros del certificado**
**sudo certbot certificates**
/etc/letsencrypt/live/

**Renovación**
Debería hacerla automáticamente.

## Cifrado de endpoints

**Cloud:** 
- GCP: “Encryption, Google-managed key”.
  
**Windows:** BitLocker. Panel de control, Sistema y Seguridad, Bitlocker, Activar Bitlocker (elegir TPM)

**Linux:** VeraCrypt. VeraCrypt, “Create Volume", Standard Volume (elegir AES)

**Bases de Datos PostgreSQL**: pgcrypto
- Crear Tabla:
CREATE TABLE secure_data (
    id SERIAL PRIMARY KEY,
    data BYTEA
);

- Insertar datos cifrados:
INSERT INTO secure_data (data)
VALUES (pgp_sym_encrypt('dato secreto','mi_clave'));

- Leer datos:
SELECT pgp_sym_decrypt(data,'mi_clave') FROM secure_data;


---

## Manual de Autenticación


### Autenticación multifactor (MFA)

Añade un segundo factor de verificación además de la contraseña.

### Opciones de MFA

**TOTP o App de autenticación**
- Google Authenticator, Authy, Microsoft Authenticator

**SMS / Email OTP**
- Servicio de envío de SMS (Twilio, Nexmo) o email (SMTP seguro).

**Hardware / USB token**
- YubiKey, Feitian, NitroKey

**Biometría**
- Reconocimiento facial, huella dactilar, iris, integrado con Windows Hello, TouchID, Android Biometric API

**MFA cloud**
GCP: IAM & Admin, Security, 2-Step Verification, Enforce.


#### Gestión de contraseñas

- Longitud mínima: 12 caracteres
- Mezcla de mayúsculas, minúsculas, números y símbolos
- No reutilizar contraseñas antiguas
- Cambio cada 2-3 meses
- Nunca almacenarlas en texto plano

**Herramientas de gestión de contraseñas:**
- **Cloud:** GCP Secret Manager
- **Local / On-prem:** Hashicorp Vault, KeePass, Bitwarden, 1Password
- **CI/CD:** en pipelines, no en repositorio

---

## Control de accesos

### Firewall
Habilitar logging de firewall (UFW)

activar UFW
```bash
sudo ufw enable
sudo ufw logging on
```
ver logs
```bash
sudo tail -f /var/log/ufw.log
```

### Forwarding de logs
```bash
Con Kibana o Wazuh (TCP, puerto 514)
sudo systemctl restart rsyslog
```
verificar envío:
```bash
sudo logger "test log forwarding"
```
en servidor central ver que llega

### Auditd 
Audita cambios
```bash
sudo apt install -y auditd audispd-plugins
```

## Okta
Gestión de identidad y MFA
Okta es un Identity Provider (IdP) en la nube que centraliza usuarios, autenticación, MFA y SSO (Single Sign-On) para aplicaciones internas y externas.  

**¿Qué tiene Okta?**
- MFA integrado (TOTP, SMS, push notification, hardware token, biometría)
- Gestión centralizada de los usuarios y de permisos
- Compatible con LDAP/AD y SaaS
- Single Sign-On para apps web, móviles y APIs
- Integración con aplicaciones (SAML, OIDC, SCIM para sincronización de usuarios).
- Da SDKs y APIs para verificar tokens o recibir notificaciones push.
- Permite monitorización y auditoría, ver logs de accesos, alertas automáticas para eventos, etc.

---

## Gestión de vulnerabilidades y parches

### Principios
- Mantener sistemas operativos, aplicaciones y dependencias siempre actualizadas.
- Revisar y aplicar parches de seguridad en cuanto se publiquen.
- Usar fuentes oficiales de proveedores y repositorios seguros.
- Programar ciclos de parcheo regulares (ej: mensual) y revisiones de seguridad.

---

### Monitoreo de vulnerabilidades (CVE)
- Consultar **bases de datos oficiales**:
  - NVD (National Vulnerability Database)
  - CVE Details
  - Security advisories de proveedores (Microsoft, Red Hat, Debian, etc.)
- Implementar **alertas automáticas** para CVEs críticos relacionados con el stack en uso.

---

### Herramientas de escaneo
- **OWASP ZAP** → Detección de vulnerabilidades en aplicaciones web.
- **Nikto** → Escáner de servidores web para configuraciones inseguras.
- **Snyk** → Análisis de dependencias, librerías y contenedores.
- **OpenVAS / Greenbone** → Escaneo de red y servicios.
- **Clair o Trivy** → Escaneo de imágenes de contenedores.

Ejemplo con Trivy en Docker:
```bash
docker run --rm aquasec/trivy image nginx:latest

Gestión de parches

Inventario: identificar sistemas, versiones y software en uso.

Evaluación: priorizar parches según criticidad (CVSS, exposición a internet).

Aplicación: desplegar parches en entornos de prueba antes de producción.

Automatización: usar herramientas como Ansible, Puppet o WSUS para aplicar parches.

Verificación: confirmar que el parche se aplicó y no rompió dependencias.

Registro: documentar cambios para auditoría.
